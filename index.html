<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ„ AI é­”æ³•åœ£è¯æ ‘</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        #launch-btn { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 100; padding: 15px 30px; background: #ff0055; color: white; border: none; border-radius: 30px; cursor: pointer; font-size: 18px; box-shadow: 0 0 20px #ff0055; }
        #video-input { position: fixed; bottom: 10px; right: 10px; width: 120px; height: 90px; border-radius: 10px; transform: scaleX(-1); z-index: 10; border: 1px solid rgba(255,255,255,0.3); object-fit: cover; }
    </style>
</head>
<body>

<button id="launch-btn">âœ¨ å¼€å¯åœ£è¯é­”æ³•</button>
<video id="video-input" playsinline webkit-playsinline muted></video>

<script src="https://cdn.staticfile.org/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
let scene, camera, renderer, particles, particleMaterial;
let handScale = 1.0;

function initTree() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const geometry = new THREE.BufferGeometry();
    const pos = [];
    const colors = [];
    
    // ç”Ÿæˆåœ£è¯æ ‘å½¢çŠ¶çš„ç²’å­
    for(let i=0; i<15000; i++) {
        let y = Math.random() * 5 - 2.5; 
        let radius = (2.5 - y) * 0.5; // è¶Šå¾€ä¸ŠåŠå¾„è¶Šå°ï¼Œå½¢æˆé”¥å½¢
        let angle = Math.random() * Math.PI * 2;
        let r = Math.pow(Math.random(), 0.6) * radius;
        pos.push(Math.cos(angle)*r, y, Math.sin(angle)*r);
        
        // æ¸å˜è‰²ï¼šåº•éƒ¨æ·±ç»¿ï¼Œé¡¶éƒ¨æµ…ç»¿/çº¢
        colors.push(0, 0.5 + (y+2.5)/10, 0.2); 
    }
    
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    particleMaterial = new THREE.PointsMaterial({ 
        size: 0.03, 
        vertexColors: true, 
        transparent: true, 
        blending: THREE.AdditiveBlending 
    });

    particles = new THREE.Points(geometry, particleMaterial);
    scene.add(particles);
}

async function initAI() {
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5});
    hands.onResults(res => {
        if(res.multiHandLandmarks && res.multiHandLandmarks[0]) {
            const lm = res.multiHandLandmarks[0];
            // è®¡ç®—å¤§æ‹‡æŒ‡å’Œé£ŸæŒ‡è·ç¦»
            const d = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
            handScale = d * 8; // å°†æ‰‹åŠ¿æ˜ å°„åˆ°ç¼©æ”¾æ¯”ä¾‹
        }
    });

    const cam = new Camera(document.getElementById('video-input'), {
        onFrame: async () => { await hands.send({image: document.getElementById('video-input')}); },
        width: 480, height: 360
    });
    return cam.start();
}

document.getElementById('launch-btn').onclick = async () => {
    document.getElementById('launch-btn').style.display = 'none';
    initTree();
    await initAI();
    animate();
};

function animate() {
    requestAnimationFrame(animate);
    particles.rotation.y += 0.01;
    // ä¸æ»‘ç¼©æ”¾æ•ˆæœ
    let targetScale = Math.max(0.5, handScale);
    particles.scale.setScalar(THREE.MathUtils.lerp(particles.scale.x, targetScale, 0.1));
    renderer.render(scene, camera);
}
</script>
</body>
</html>



