<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ„ AI æ¢¦å¹»åœ£è¯æ ‘</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        #launch-btn { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 100; padding: 15px 35px; background: linear-gradient(45deg, #00ffcc, #0066ff); color: white; border: none; border-radius: 30px; cursor: pointer; font-size: 18px; font-weight: bold; box-shadow: 0 0 20px rgba(0,255,204,0.5); }
        /* éšè—æ‘„åƒå¤´ç”»é¢ */
        #video-input { display: none; }
    </style>
</head>
<body>

<button id="launch-btn">ğŸ å¼€å¯æˆ‘çš„åœ£è¯é­”æ³•</button>
<video id="video-input" playsinline webkit-playsinline muted></video>

<script src="https://cdn.staticfile.org/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
let scene, camera, renderer, tree, snow, handScale = 1.0;

function initMagic() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 5;
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 1. åˆ›å»ºåœ£è¯æ ‘ï¼ˆå¸¦å½©è‰²è£…é¥°ç¯ï¼‰
    const treeGeo = new THREE.BufferGeometry();
    const treePos = [], treeCols = [];
    for(let i=0; i<20000; i++) {
        let y = Math.random() * 5 - 2.5; 
        let radius = (2.5 - y) * 0.5;
        let angle = Math.random() * Math.PI * 2;
        let r = Math.pow(Math.random(), 0.7) * radius;
        treePos.push(Math.cos(angle)*r, y, Math.sin(angle)*r);
        
        // 80% ç»¿è‰²ç²’å­ï¼Œ20% å½©è‰²è£…é¥°ç¯ï¼ˆçº¢/é‡‘ï¼‰
        if(Math.random() > 0.8) {
            Math.random() > 0.5 ? treeCols.push(1, 0.8, 0) : treeCols.push(1, 0, 0.3); // é‡‘è‰²æˆ–çº¢è‰²
        } else {
            treeCols.push(0, 0.6 + (y+2.5)/10, 0.3); // æ¸å˜ç»¿
        }
    }
    treeGeo.setAttribute('position', new THREE.Float32BufferAttribute(treePos, 3));
    treeGeo.setAttribute('color', new THREE.Float32BufferAttribute(treeCols, 3));
    tree = new THREE.Points(treeGeo, new THREE.PointsMaterial({ size: 0.025, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending }));
    scene.add(tree);

    // 2. åˆ›å»ºèƒŒæ™¯é™é›ª
    const snowGeo = new THREE.BufferGeometry();
    const snowPos = [];
    for(let i=0; i<2000; i++) {
        snowPos.push(Math.random()*20-10, Math.random()*20-10, Math.random()*20-10);
    }
    snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowPos, 3));
    snow = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.03, transparent: true, opacity: 0.8 }));
    scene.add(snow);
}

async function initAI() {
    const hands = new Hands({locateFile: (f) => `https://fastly.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6});
    hands.onResults(res => {
        if(res.multiHandLandmarks && res.multiHandLandmarks[0]) {
            const lm = res.multiHandLandmarks[0];
            const d = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
            handScale = 0.5 + d * 6;
        }
    });
    const cam = new Camera(document.getElementById('video-input'), {
        onFrame: async () => { await hands.send({image: document.getElementById('video-input')}); },
        width: 480, height: 360
    });
    return cam.start();
}

document.getElementById('launch-btn').onclick = async () => {
    document.getElementById('launch-btn').style.display = 'none';
    initMagic();
    await initAI();
    animate();
};

function animate() {
    requestAnimationFrame(animate);
    tree.rotation.y += 0.01;
    // é›ªèŠ±é£˜è½
    const positions = snow.geometry.attributes.position.array;
    for(let i=1; i<positions.length; i+=3) {
        positions[i] -= 0.02;
        if(positions[i] < -10) positions[i] = 10;
    }
    snow.geometry.attributes.position.needsUpdate = true;
    
    let s = THREE.MathUtils.lerp(tree.scale.x, handScale, 0.1);
    tree.scale.setScalar(s);
    renderer.render(scene, camera);
}
</script>
</body>
</html>




